# Project Structure: onion

Песочница для проверки различных гипотез в области организации структуры проекта.

Требования:
- приложение - коноль, несколько методов для чтения и записи данных
- данные модели хранятся удалённо, чтение и запись API / gRPC

Легенда. Виртуальная книжная полка, основные действия:
- загрузить на полку книгу (книги хранятся в удалённом репозитории, доступ через API)
- получить книгу с полки
- у книги есть Автор, связь один к одному (данные хранятся в локальном репозитории)

Структура:
- **application**
  Слой первичной валидации и подготовки конечного ответа.
  Получаем очищенные данные, с точки зрения типа и структуры данных, переводим данные в абстракции нашего домена, 
  и через интерфейсы работаем с данными, согласно бизнес логике и при помощи **infrastructure** layer.
- **domain**
  Основная бизнес логика.
- **infrastructure**
  Код организующий связь между доменом и инфраструкторой.
  Следим чтобы сюда не просачивалась бизнес логика нашего домена. Здесь в основном работаем с внешними системами - 
  базы данных, кеши, внешние ресурсы, шины данных и прочее.
- **presentation**
  Точка входа: API / CLI / gRPC / etc
  Собственно на этом уровне и живут http/cli framework, обязанность которых получить набор аргументов, 
  минимально обработать согласно с общепринятой логикой и передать на следующий уровень - приложение (**application**).

### Вопросики

- где создавать агрегаты, как организовать связи между доменными моделями - в доменном сервисе или на уровне приложения?
  В настоящий момент склоняюсь к тому что Interactor на уровне **application**, а Aggregat на уровне **domain**.
- правильно ли изолировать **domain** сервисы от репозиториев?
  Допускаю, что при сложной логике приложения не удасться избежать связи доменного сервиса и **infrastructure**.

### Плюсы

+ domain ничего не знает об application, что отлично инкапсулирует логику от окружения;
+ infrastructure так же в достаточной степени изолирована от application, через интерфейсы;
+ достаточно легко написать тресты к любому слою приложения;

## Docker

```shell
docker pull ghcr.io/kuaukutsu/php:8.3-cli
```

Container:
- `ghcr.io/kuaukutsu/php:${PHP_VERSION}-cli` (**default**)
- `jakzal/phpqa:php${PHP_VERSION}`

### Run example

```shell
make run-book
```

```shell
make run-book-find
```

```shell
make run-author
```

```shell
make run-author-create
```

### Static analysis

The code is statically analyzed with [Psalm](https://psalm.dev/). To run static analysis:

```shell
make psalm
```

```shell
make phpstan
```

```shell
make check
```

### Code Sniffer

```shell
make phpcs
```

### Rector

```shell
make rector
```

### Unit testing

The package is tested with [PHPUnit](https://phpunit.de/). To run tests:

```shell
make phpunit
```
**phpunit**, чтобы перейти на 11 версию, нужно отказываться от psalm,
который цепляется за четвертую версию парсера от Никиты Попова (https://github.com/nikic/PHP-Parser).
Плавно переезжаем на phpstan?.

